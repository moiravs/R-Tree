
\documentclass[utf8]{article}
\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{fullpage}
\usepackage{lipsum}
\usepackage{multirow}

\nocite{*}
\setlength\parindent{24pt}

\begin{document}
\begin{titlepage}


\author{Andrius Ezerskis \& Moïra Vanderslagmolen}
\title{Projet d'Algorithmique: R-trees}

\maketitle
\end{titlepage}
\tableofcontents
\newpage
\begin{large}



\section{Introduction}
\indent
\par


\par
\section{RTree}
\subsection{Création RTree}
\par
\indent
Au début, nous avions N, le truc maximum pr les RTree en attribut de la classe RTree et défini là dedans.
Pour optimiser notre programme, nous avons décidé de le passer en paramètre.
Grâce à cette amélioration, les 8 tests que nous avons fait tourner ont pris
4,429 secondes au total au lieu de 5,865 secondes.

\subsection{Split Linéaire}
\par
\indent
Au début, nous copions l'entiereté du vecteur des enfants du node choisi pour
split. Puis nous vidons ce vecteur et nous rajoutons les seeds choisies. Et puis
seulement avec le vecteur copié nous ajoutions au fur et à mesure au seeds
choisies. Nous nous sommes dit qu'on perdait bcp de temps à copier l'entiereté
du vecteur, surtout sur des gros vecteurs.

Nous avons donc changé l'ordre, d'abord nous appelons pickNext pour qu'il
rajoute les enfants aux seeds, puis nous vidons le vecteur du node à spliter et
rajoutons les splits seeds.

Grâce à cette amélioration, les 8 tests que nous avons fait tourner ont pris
5,865 secondes au total au lieu de 6,778 secondes.
\par
\subsection{Split Quadratique}
\par
\indent
Dans le split quadratique, nous itérons à travers le vecteur d'enfants du node à
split et nous prenons les deux noeuds les plus éloignés. Nous avons vite
remarqué qu'il n'était pas nécéssaire de faire un double for en itérant chaque
élément dans le vecteur. En effet, si nous calculons pour l'aire pour le noeud A
et pour le noeud B, il ne faut pas recalculer pour le noeud B et le noeud A, de
même qu'il ne faut pas calculer pour l'aire pour le noeud A et le noeud A. Nous
faisons donc deux boucles for, l'une itérant dans le vecteur entier de
sous-noeuds, l'autre commençant à l'indice de la précédente boucle + 1. De cette
manière, nous commençons avec le noeud A et calculons avec le noeud B et tous
les autres noeuds restants, puis le noeud B avec le noeud C et ainsi de suite.
Cela nous permet de réduire le temps d'exécution.
\par


\section{Structure du code}

\par
\subsection{MBRNode}
\par
\indent
MBRNode représente les noeuds des R-Tree. Elle contient un label, un polygone, 
des enfants (sauf si c'est une feuille) et un parent (sauf si c'est la racine de
l'arbre). Si le noeud n'est pas une feuille, alors son label sera "SplitSeed",
car il regroupe plusieurs polygones.

\subsection{RTreeLinear}\label{RTreeLinear}
\par
\indent
RTreeLinear représente l'implémentation du R-Tree avec l'algorithme de split linéaire.
\subsection{RTreeQuadratic}\label{RTreeQ}

\subsection{RTree}
\par
\indent
RTree est une classe abstraite. Elle permet de regrouper ensemble les méthodes
communes à RTreeLinear et RTreeQuadratic, par exemple la
recherche d'un noeud (searchNode), l'initialisation de la classe


\subsection{FileLoader}
\par
\indent
Cette classe permet de charger le fichier en mémoire. Nous avons implémenté
cette classe afin de facilement changer la façon dont les fichiers sont chargés
en mémoire.

\section{Expérience sur données réelles}
\subsection{Présentation des tests}
\begin{enumerate}
    \item Carte de la belgique - Algorithme linéaire - Campus universitaire
    \item Carte de la belgique - Algorithme linéaire - Point pas dans le polygone
    \item Carte du monde - Algorithme linéaire - Kazakhstan
    \item Carte du monde - Algorithme linéaire - Canada
    \item Carte de la france - Algorithme linéaire - Auvergne
    \item Carte de la france - Algorithme linéaire - Guyane
    \item Carte de la belgique - Algorithme quadratique - Campus universitaire
    \item Carte de la belgique - Algorithme quadratique - Point pas dans le polygone
    \item Carte du monde - Algorithme quadratique - Kazakhstan
    \item Carte du monde - Algorithme quadratique - Canada
    \item Carte de la france - Algorithme quadratique - Auvergne
    \item Carte de la france - Algorithme quadratique - Guyane
  \end{enumerate}

  \subsection{Présentation des cartes}
  \begin{enumerate}
      \item Carte de la belgique : 19795 polygones
      \item Carte du monde : 251 polygones
      \item Carte de la france : 18 polygones
    \end{enumerate}


\subsection{Résultats des tests}
\par
\indent
Temps en millisecondes de la fonction search en fonction des différents tests et valeurs.

\begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}|  }
 \hline
 \multicolumn{4}{|c|}{Temps en millisecondes de la fonction search} \\
 \hline
 Test & N=4 & N = 500 & N = 10000\\
 \hline
 Test1   & 15    & 15&   17\\
 Test2 &   1  & 1   & 1\\
 Test3 & 76 & 8&  11\\
 Test4    & 123 & 214&  219\\
 Test5 & 23& 68 & -\\
 Test6 & 3& 3 & -\\
 Test7 &   2  & 0& 2\\
 Test8 & 1  & 1   & 4\\
 Test9& 3  & 2& 2\\
 Test10& 29 & 76 & 73\\
 Test11 &29 &37& -\\
 Test12 & 2&2& -\\
 \hline
\end{tabular}

\subsection{Conclusion des tests}
\par
\indent
Nous avons donc remarqué suite à cela que le test 4 prenait beaucoup de temps,
et plus généralement les tests concernant la carte du monde (Test 3, 4, 9, 10)
et les tests concernant la carte de la france (Test 5,6,11,12). Ces tests
devraient être les plus rapides, car ils contiennent le moins de polygones, et
les algorithmes sont quadratiques et linéaires. Nous remarquons aussi que le
nombre N n'a pas d'influence sur la rapidité de notre algorithme.
\par
\indent
Nous avons aussi remarqué que l'algorithme linéaire prend beaucoup plus de temps
à chercher un point dans un polygone. En moyenne, la recherche prend 39,9
millisecondes pour l'algorithme linéaire et 13,25 millisecondes pour
l'algorithme quadratique. Nous avons donc comparé les temps d'exécution. En
moyenne, le temps d'exécution sur 6 tests pour l'algorithme quadratique est de
6,357 secondes. Le temps d'exécution sur les mêmes tests pour l'algorithme
linéaire est de 3,087 secondes. La création de l'arbre est donc beaucoup plus
rapide pour l'algorithme linéaire que pour le quadratique, ce qui est attendu vu
la complexité de chaque algorithme. Cependant, il est intéressant de noter que
la fonction de recherche prend beaucoup plus de temps dans l'algorithme
linéaire.
\par

\section{Conclusion}
\indent
\par
\par

\section{Bibliographie}

\section{Annexes}
\includegraphics[width=\textwidth]{beforeopti.png}
\includegraphics[width=\textwidth]{afterOpti.png}


\end{large}

\end{document}
